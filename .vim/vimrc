"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Machine
"""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:work_machine = has("win32") + has("win64")
"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Indentation
"""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set shiftwidth=2
set tabstop=2
set softtabstop=2
set textwidth=0

set autoindent
filetype plugin indent on
syntax enable

"things after case labels aren't indented
"so I can add braces in case statements
set cino==0

set nu

set splitright
set splitbelow

set showcmd

set nostartofline

set sidescroll=1

let g:markdown_folding = 1
"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Code Navigation
"""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('nvim-0.1.5')
  set termguicolors
  set shada="NONE"
endif

set completeopt+=longest
set showmatch
set incsearch
set ruler
set tagcase=ignore
set ignorecase
set smartcase
set lazyredraw
set hlsearch
nohl

" Match location/quickfix list error format
"  for easy use with :lgetbuffer
set errorformat+=%f\|%l\ col\ %c\|%m

set foldlevelstart=99
set foldmethod=indent

set nobackup
set nowritebackup
set undofile
set noswapfile

if has("win32")
  set directory=~/dot-files/.vim/swap//
  set undodir=~/dot-files/.vim/undo//
else
  set directory=~/.vim/swap//
  set undodir=~/.vim/swap//
endif

if has("gui_running")
  set lines=30 columns=120
  set guioptions=c
endif

set history=500
set nrformats=bin,hex,alpha
set backspace=indent,eol,start " be able to backspace over these chars

set autoread

set wildmode=list:longest,full " tab complete to longest match, second tab lists all matches
set wildignorecase " ignore case when completing file and dir names
set wildignore+=*.o
set wildignore+=*.r43
set wildignore+=*.pbi*
set wildignore+=*.lst

set virtualedit=block " allow visual mode block editing to extend past EOL

" use :find to search through all files under the current working directory
set path-=. " cwd should take precedence over directory of file
set path+=**
set path+=.

" search for tag file relative to current working directory rather than
" current file's directory
set cpoptions+=d

set laststatus=2    " always display statusline
set statusline=%<%F " file name and path
set statusline+=\ %m%r " modified, read-only flags
set statusline+=\ %y  " filetype according to vim
set statusline+=\ [%{&ff}] " show detected line endings for file
set statusline+=%=
set statusline+=\ [0x\%02.4B] " hex value under cursor showing two bytes for unicode
set statusline+=\ [%{&encoding}] " encoding for file
set statusline+=\ [%2.10(%l:%c%V%)\ \/\ %L] " line:column / total lines

if executable('rg') "name on windows
  set grepprg=rg\ --no-messages\ --vimgrep\ --max-filesize\ 5M\ --type-add\ work:include:cpp,c,asm\ --type-add\ work:\*.s43\ --type-add\ work:\*.S43\ --type-add\ work:\*.inc\ --type-add\ zig:\*.zig
  set grepformat=%f:%l:%c:%m,%f:%l:%m
elseif executable('ripgrep.rg') "name when installed from snap
  set grepprg=ripgrep.rg\ --no-messages\ --vimgrep\ --max-filesize\ 5M\ --type-add\ work:include:cpp,c,asm\ --type-add\ work:\\*.s43\ --type-add\ work:\\*.S43\ --type-add\ work:\\*.inc\ --type-add\ zig:\\*.zig
  set grepformat=%f:%l:%c:%m,%f:%l:%m
elseif executable('ag')
  set grepprg=ag\ --nogroup\ --nocolor\ --ignore-case\ --column\ --vimgrep
  set grepformat=%f:%l:%c:%m,%f:%l:%m
endif

if has("patch-8.1.0360")
  set diffopt=internal,filler,indent-heuristic,algorithm:histogram
  set diffexpr=""
elseif executable('diff')
  set diffexpr=MyDiff()
  function! MyDiff()
    let opt = ""
    if &diffopt =~ "icase"
      let opt = opt . "-i "
    endif
    if &diffopt =~ "iwhite"
      let opt = opt . "-b "
    endif
      silent execute "!diff --text --new-file --minimal " . opt . v:fname_in . " " . v:fname_new .
        \  " > " . v:fname_out
  endfunction
else
  set diffopt=filler
  set diffexpr=""
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Terminal Settings
"""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:local_terminal_name = 'LOCAL'
let s:global_terminal_name = 'GLOBAL'
let s:windows_default_term = 'C:\Users\jalexander\Program Installs\Git\bin\bash.exe'
let s:linux_default_term = '/usr/bin/env bash'
"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Key maps
"""""""""""""""""""""""""""""""""""""""""""""""""""""
"unmap windows visual mode cut to clipboard. Use for decrementing lists
silent! vunmap <c-x>
set timeout timeoutlen=1000 ttimeoutlen=200
inoremap jk <esc>
vnoremap s( c()<ESC>P
vnoremap s{ c{}<ESC>P
vnoremap s[ c[]<ESC>P
vnoremap s" c""<ESC>P
vnoremap s` c``<ESC>P
vnoremap s' c''<ESC>P
vnoremap s< c<><ESC>P
vnoremap s_ c__<ESC>P
vnoremap s* c**<ESC>P
nnoremap ds( %x<c-o>x
nnoremap ds{ %x<c-o>x
nnoremap ds" %x<c-o>x
nnoremap ds` %x<c-o>x
nnoremap ds' %x<c-o>x
nnoremap dif viwl%d
nnoremap yif viwl%y
vnoremap <Bslash>bs c{<CR>}<ESC>P=i{
vnoremap s<SPACE> di<SPACE><SPACE><ESC>P
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
nnoremap <c-j> :lnext<CR>z.
nnoremap <c-k> :lprevious<CR>z.
nnoremap J :cnext<CR>z.
nnoremap K :cprevious<CR>z.
nnoremap <Bslash>j :lnewer<CR><CR>
nnoremap <Bslash>k :lolder<CR><CR>
nnoremap <Bslash>h :nohl<CR>
nnoremap <SPACE> za
nnoremap <Bslash>. 10<c-w>>
nnoremap <Bslash>, 10<c-w><
nnoremap <Bslash>- 10<c-w>-
nnoremap <Bslash>= 10<c-w>+
nnoremap <Bslash>l :LocationListToggle<CR>
nnoremap <Bslash>c :QuickFixListToggle<CR>
vnoremap <Bslash>/ :Comment<CR>
vnoremap <Bslash>\ :Uncomment<CR>
nnoremap <Bslash>/ :Comment<CR>
nnoremap <Bslash>\ :Uncomment<CR>
nnoremap <Bslash>] :TogglePreview<CR>
nnoremap <c-Bslash>n :VerticalSplitNoteToggle<CR>
nnoremap <c-Bslash>t :GlobalTerminalToggle<CR>
nnoremap <c-Bslash>vt :GlobalVerticalTerminalToggle<CR>
tnoremap <c-Bslash>t <c-w>:GlobalTerminalToggle<CR>
tnoremap <c-Bslash>vt <c-w>:GlobalVerticalTerminalToggle<CR>
nnoremap <c-Bslash>lt :TerminalToggle<CR>
nnoremap <c-Bslash>lvt :VerticalTerminalToggle<CR>
tnoremap <c-Bslash>lt <c-w>:TerminalToggle<CR>
tnoremap <c-Bslash>lvt <c-w>:VerticalTerminalToggle<CR>
nnoremap <c-Bslash>dt <c-w>:DebuggingTerminalToggle<CR>
tnoremap <c-Bslash>dt <c-w>:DebuggingTerminalToggle<CR>
" Svn directory diff hotkeys
nnoremap <Bslash>q :SvnDirDiffPrevFile<CR>
nnoremap <Bslash>w :SvnDirDiffNextFile<CR>
nnoremap <c-w>] yiw:vert stag! <c-r>"<CR>
nnoremap <c-w>g] yiw:vert stselect! <c-r>"<CR>
" yank inside visual selection, cursor returns to where it was, can specify any register
" from https://ddrscott.github.io/blog/2016/yank-without-jank/
vnoremap <expr>y "my\"" . v:register . "y`y"
vnoremap /  y/<c-R>"<CR>
" * key doesn't auto jump
nnoremap <silent> * :let @/=expand("<cword>")<CR>:set hls<CR>:%s///gn<CR>
vnoremap <silent> * y:let @/=@"<CR>:set hls<CR>:%s///gn<CR>

"lgrep search hotkeys
if s:work_machine
  command! -nargs=+ -complete=tag Lgrep lgrep -twork <args>
else
  command! -nargs=+ -complete=tag Lgrep lgrep <args>
endif
nnoremap <Bslash>s "myiw:Lgrep "<c-R>m"<SPACE>
nnoremap <Bslash>S "myiw:lgrep "<c-R>m"<SPACE>
vnoremap <Bslash>s "my:Lgrep<SPACE>"<c-R>m"<SPACE>
nnoremap <Bslash>f :let @m=expand('<cfile>')<CR>:Find<SPACE><c-R>m
vnoremap <Bslash>f "my:Find<SPACE><c-R>m

tnoremap <c-g><c-t> <c-w>:normal gt<CR>
tnoremap <c-g>t     <c-w>:normal gT<CR>
nnoremap <c-g><c-t> <c-w>:normal gt<CR>
nnoremap <c-g>t     <c-w>:normal gT<CR>

tnoremap <c-\>N <c-w>:NewTermTab<CR>
nnoremap <c-\>N <c-w>:NewTermTab<CR>

" Command line history completion
cnoremap <c-j> <Down>
cnoremap <c-k> <Up>

"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""
function! s:SetupPlugins()
"called on autocommand that is triggered after
"plugins are setup (post vimrc sourcing)
  if exists(":AsyncRun")
    let s:async_run_mod = "AsyncRun "
  else
    let s:async_run_mod = "!"
  endif
endfunction
if v:vim_did_enter
  call s:SetupPlugins()
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -nargs=? -complete=dir Ctags call s:EasyCtags(<q-args>)
function! s:EasyCtags(...)
  let rel_arg = "y"
  if has('win32')
    let rel_arg = "always"
  endif
  if a:0 > 0 "&& (match(a:000, '^.\+$') == 0)
    let l:dir_and_extra_parms = ""
    for item in a:000
    let l:dir_and_extra_parms ..= item
    endfor
  else
    let l:dir_and_extra_parms = getcwd(win_getid())
  endif
  let langMapChange = ['c', 'cpp', 'msp', 'asm']
  let executableString = ""
  if index(langMapChange, &ft) >= 0
    let executableString ..= s:async_run_mod . 'ctags -R --tag-relative='.rel_arg.' --languages=C,C++ '.l:dir_and_extra_parms.' && ctags -Ra --tag-relative='.rel_arg.' --langmap=Asm:+.s43.S43.h.inc '.l:dir_and_extra_parms
  else
    let executableString ..= s:async_run_mod . 'ctags -R --tag-relative='.rel_arg.' '.l:dir_and_extra_parms
  endif
  echo executableString
  execute(executableString)
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! LocationListToggle call s:LocationListToggle()
function! s:LocationListToggle()
  if exists("w:location_list_orig") "we are in location list
    execute w:location_list_orig."wincmd w"
    unlet w:location_list_winnr
    lclose
  elseif exists("w:location_list_winnr") "we are in original window
    unlet w:location_list_winnr
    lclose
  else
    let t:temp1 = winnr() "original window number
    lopen 15
    let t:temp2 = winnr() "location list window number tied to previous window
    let w:location_list_orig = t:temp1
    execute w:location_list_orig."wincmd w"
    let w:location_list_winnr = t:temp2
    execute w:location_list_winnr."wincmd w"
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! QuickFixListToggle call s:QuickFixListToggle()
let s:qftoggle = 0
function! s:QuickFixListToggle()
  if s:qftoggle == 1
    silent! botright cclose
    let s:qftoggle = 0
  else
    silent! botright copen
    let s:qftoggle = 1
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:comment_characters = {
      \"c"      : "//",
      \"cpp"    : "//",
      \"cs"     : "//",
      \"zig"    : "//",
      \"asm"    : "//",
      \"msp"    : ";",
      \"sh"     : "#",
      \"pov"    : "#",
      \"nim"    : "#",
      \"make"   : "#",
      \"vim"    : "\"",
      \"dosbatch": "REM ",
      \"python" : "#",
      \}
command! -range Comment <line1>,<line2>call s:Comment()
function! s:Comment()
  if (has_key(s:comment_characters,&filetype))
    let comment_at_caret = "s:\\v(^\\s*)(\\S):\\1".s:comment_characters[&filetype]."\\2:e"
    let comment_at_0 = "s:\\v(^.*$):".s:comment_characters[&filetype]."\\1:e"
    execute comment_at_0
  else
    echo "Unknown comment character for filetype, see vimrc"
  endif
endfunction
command! -range Uncomment <line1>,<line2>call s:Uncomment()
function! s:Uncomment()
  if (has_key(s:comment_characters,&filetype))
    execute "s:\\v(^\\s*)".s:comment_characters[&filetype].":\\1:e"
  else
    echo "Unknown comment character for filetype, see vimrc"
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -range -nargs=1 MassReplace <line1>,<line2>call s:MassReplace(<args>)
function! s:MassReplace(dict)
    for [regex,replacement] in items(a:dict)
        exe "silent! s;\\v".regex.";".replacement.";g"
    endfor
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -complete=file_in_path -nargs=1 FindLine call s:FindLine(<q-args>)
function! s:FindLine(file_line)
  let split_path = split(a:file_line,':')
  let split_path_len = len(split_path)
  if split_path_len == 0 || split_path_len > 2
    echo "FindLine - Invalid Parameter"
  else
    let found_file = findfile(split_path[0])
    if filereadable(expand(found_file))
      exe "edit ".found_file
      if split_path_len == 2 && !(split_path[1] =~ '\D')
        exe "silent! normal! ".split_path[1]."gg"
        normal! z.
      endif
    else
      echo "Findline - File Not Readable"
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! TogglePreview call s:TogglePreview()
function! s:TogglePreview()
  if exists("t:pwin")
    unlet t:pwin
    pclose
  else
    let t:pwin = 1
    wincmd }
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! VerticalSplitNoteToggle call s:VerticalSplitNoteToggle()
function! s:VerticalSplitNoteToggle()
  if exists("t:notes_win_number")
    if win_id2win(t:notes_win_number)
      execute win_id2win(t:notes_win_number)."close!"
    endif
    unlet t:notes_win_number
  else
    botright vsplit NOTES.md
    let t:notes_win_number = win_getid(winnr())
    vertical resize 85
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -nargs=? NewTermTab call s:MakeNewTermTab(<q-args>)
let s:term_num = 0
function! s:MakeNewTermTab(...)
  if a:0 > 0 && (match(a:000, '^.\+$') == 0)
    let l:term_name = a:1
  else
    let l:term_name = 'Terminal_'.s:term_num
    let s:term_num += 1
  endif
  $tabnew
  if has("win32")
    call term_start(s:windows_default_term,{'curwin':1,'term_name':l:term_name,'norestore':1})
  else
    call term_start(s:linux_default_term,{'curwin':1,'term_name':l:term_name})
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
" Toggleable terminal is specific to each tab
command! TerminalToggle call s:TerminalToggle()
function! s:TerminalToggle()
  if exists("t:terminal_win_num")
    if win_id2win(t:terminal_win_num)
      execute win_id2win(t:terminal_win_num)."wincmd w"
      hide
    endif
    unlet t:terminal_win_num
  else
    botright new
    resize 16 "16 lines tall
    let t:terminal_win_num = win_getid(winnr())
    if exists("t:terminal_buf_num") && bufexists(t:terminal_buf_num)
      execute "buf ".t:terminal_buf_num
    else
      if has("win32")
        call term_start(s:windows_default_term,{'curwin':1,'term_name':s:local_terminal_name,'norestore':1})
      else
        call term_start(s:linux_default_term,{'curwin':1,'term_name':s:local_terminal_name})
      endif
      let t:terminal_buf_num = bufnr("%")
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
" Toggleable terminal is specific to each tab
command! VerticalTerminalToggle call s:VerticalTerminalToggle()
function! s:VerticalTerminalToggle()
  if exists("t:vertical_terminal_win_num")
    if win_id2win(t:vertical_terminal_win_num)
      execute win_id2win(t:vertical_terminal_win_num)."wincmd w"
      hide
    endif
    unlet t:vertical_terminal_win_num
  else
    botright vnew
    let t:vertical_terminal_win_num = win_getid(winnr())
    if exists("t:vertical_terminal_buf_num") && bufexists(t:vertical_terminal_buf_num)
      execute "buf ".t:vertical_terminal_buf_num
    else
      if has("win32")
        call term_start(s:windows_default_term,{'curwin':1,'term_name':s:local_terminal_name,'norestore':1})
      else
        call term_start(s:linux_default_term,{'curwin':1,'term_name':s:local_terminal_name})
      endif
      let t:vertical_terminal_buf_num = bufnr("%")
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
" Toggleable terminal is global and shared amongst all tabs
command! GlobalTerminalToggle call s:GlobalTerminalToggle()
function! s:GlobalTerminalToggle()
  if exists("t:global_terminal_win_num")
    if win_id2win(t:global_terminal_win_num)
      execute win_id2win(t:global_terminal_win_num)."wincmd w"
      hide
    endif
    unlet t:global_terminal_win_num
  else
    botright new
    resize 16 "16 lines tall
    let t:global_terminal_win_num = win_getid(winnr())
    if exists("g:global_terminal_buf_num") && bufexists(g:global_terminal_buf_num)
      execute "buf ".g:global_terminal_buf_num
    else
      if has("win32")
        call term_start(s:windows_default_term,{'curwin':1,'term_name':s:global_terminal_name,'norestore':1})
      else
        call term_start(s:linux_default_term,{'curwin':1,'term_name':s:global_terminal_name})
      endif
      let g:global_terminal_buf_num = bufnr("%")
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
" Toggleable terminal is global and shared amongst all tabs
command! GlobalVerticalTerminalToggle call s:GlobalVerticalTerminalToggle()
function! s:GlobalVerticalTerminalToggle()
  if exists("t:global_vertical_terminal_win_num")
    if win_id2win(t:global_vertical_terminal_win_num)
      execute win_id2win(t:global_vertical_terminal_win_num)."wincmd w"
      hide
    endif
    unlet t:global_vertical_terminal_win_num
  else
    botright vnew
    let t:global_vertical_terminal_win_num = win_getid(winnr())
    if exists("g:global_vertical_terminal_buf_num") && bufexists(g:global_vertical_terminal_buf_num)
      execute "buf ".g:global_vertical_terminal_buf_num
    else
      if has("win32")
        call term_start(s:windows_default_term,{'curwin':1,'term_name':s:global_terminal_name,'norestore':1})
      else
        call term_start(s:linux_default_term,{'curwin':1,'term_name':s:global_terminal_name})
      endif
      let g:global_vertical_terminal_buf_num = bufnr("%")
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
" Toggleable terminal is global and shared amongst all tabs
command! DebuggingTerminalToggle call s:DebuggingTerminalToggle()
function! s:DebuggingTerminalToggle()
  if exists("t:debugging_terminal_win_num")
    if win_id2win(t:debugging_terminal_win_num)
      execute win_id2win(t:debugging_terminal_win_num)."wincmd w"
      hide
    endif
    unlet t:debugging_terminal_win_num
  else
    botright vnew
    let t:debugging_terminal_win_num = win_getid(winnr())
    if exists("g:debugging_terminal_buf_num") && bufexists(g:debugging_terminal_buf_num)
      execute "buf ".g:debugging_terminal_buf_num
    else
      if has("win32")
        call term_start(s:windows_default_term,{'curwin':1,'term_name':'GDB','norestore':1})
      else
        call term_start(s:linux_default_term,{'curwin':1,'term_name':'GDB'})
      endif
      let g:debugging_terminal_buf_num = bufnr("%")
    endif
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! SvnDiffOpen call s:SvnDiffOpen()
function! s:SvnDiffOpen()
  let t:diff_file_name = expand('%')
  let t:diff_win_num = winnr()
  let t:diff_ft = &filetype
  execute "vert new"
  execute "read !svn cat \"" . t:diff_file_name . "\""
  let t:svn_head_buf_number = bufnr('%')
  execute "set ft=".t:diff_ft
  execute "diffthis"
  execute "normal gg"
  wincmd h
  execute "diffthis"
  execute "normal gg"
endfunction

command! SvnDiffClose call s:SvnDiffClose()
function! s:SvnDiffClose()
  execute "windo diffoff"
  if exists("t:svn_head_buf_number")
    execute "bd! " . t:svn_head_buf_number
    unlet t:svn_head_buf_number
  endif
  if exists("t:diff_win_num")
    execute t:diff_win_num . "wincmd w"
    unlet t:diff_win_num
  endif
endfunction

command! SvnDirDiffNextFile call s:SvnDirDiffNextFile()
function! s:SvnDirDiffNextFile()
  if exists("t:svn_dir_diff_in_progress")
    if exists("t:diff_entry_num") && (t:diff_entry_num < t:num_dir_diff_files)
      call s:SvnDiffClose()
      cnext
      call s:SvnDiffOpen()
      let t:diff_entry_num += 1
    else
      echoerr "No more modified files"
    endif
  else
    echoerr "No directory diff in progress."
  endif
endfunction

command! SvnDirDiffPrevFile call s:SvnDirDiffPrevFile()
function! s:SvnDirDiffPrevFile()
  if exists("t:svn_dir_diff_in_progress")
    if exists("t:diff_entry_num") && (t:diff_entry_num > 1)
      call s:SvnDiffClose()
      cprev
      call s:SvnDiffOpen()
      let t:diff_entry_num -= 1
    else
      echoerr "No more modified files"
    endif
  else
    echoerr "No directory diff in progress."
  endif
endfunction

command! SvnDirDiff call s:SvnDirDiff()
function! s:SvnDirDiff()
  if exists("t:svn_dir_diff_in_progress")
    unlet t:svn_dir_diff_in_progress
    call s:SvnDiffClose()
    cclose
    let l:diff_tab = tabpagenr()
    execute t:original_tab."tabnext"
    execute l:diff_tab."tabclose"
  else
    let l:original_tab = tabpagenr()
    $tabnew
    let t:original_tab = l:original_tab
    nohl
    botright copen
    set modifiable
    normal! ggVGdd
    read !svn diff --summarize
    if line('$') < 2
      echoerr "No modified files found."
      quit!
      return
    endif
    normal! ggdd
    %normal! dw
    setlocal errorformat=%f
    cgetbuffer
    let qflist = getqflist()
    let t:num_dir_diff_files = len(qflist)
    if t:num_dir_diff_files
      let t:svn_dir_diff_in_progress = 1
      cfirst
      let t:diff_entry_num = 1
      call s:SvnDiffOpen()
    endif
  endif
endfunction

command! SvnBlame call s:SvnBlame()
function! s:SvnBlame()
  if exists("g:svn_blame_in_progress")
    unlet g:svn_blame_in_progress
    windo diffoff
    tabprevious
    if exists("g:svn_head_buf_number")
      execute "bd! " . g:svn_head_buf_number
    endif
    if exists("g:svn_prev_buf_number")
      execute "bd! " . g:svn_prev_buf_number
    endif
    if exists("g:blame_line_no")
      execute "normal ".g:blame_line_no."gg"
    endif
  else
    let g:svn_blame_in_progress = 1
    let l:blame_file_name = expand('%')
    let g:blame_line_no = line('.')
    let l:blame_cwd = getcwd()
    "what is yank line for?
    normal! yy
    tab new
    "retain working directory information
    execute "lcd ". l:blame_cwd
    let g:svn_prev_buf_number = bufnr('%')
    vert new
    let g:svn_head_buf_number = bufnr('%')
    execute "read !svn blame " . l:blame_file_name
    normal! ggdd
    " copy first word (blame revision number for that line)
    execute "normal ".g:blame_line_no."gg^"
    let l:blameno = expand("<cword>")
    let l:blameprevno = l:blameno - 1
    exe "normal W"
    let l:line_author = expand("<cword>")
    "delete contents of blame buffer
    normal! ggVGd
    "read in revision on right
    execute "read !svn cat " . l:blame_file_name . " -r " . l:blameno
    let l:blameinfo = join([l:blame_file_name,":",l:blameno,":",l:line_author], "")
    execute "let g:_ = append(0, \"".l:blameinfo."\")"
    "read in prev revision on left
    wincmd h
    execute "read !svn cat " . l:blame_file_name . " -r " . l:blameprevno
    "diff
    execute "windo diffthis"
    execute "normal gg"
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -nargs=? -complete=tag Match1 call s:MyMatch1(<q-args>)
function! s:MyMatch1(...)
  if a:1 == ""
    match none
  else
    execute "match wildmenu `\\v".a:1."`"
  endif
endfunction
command! -nargs=? -complete=tag Match2 call s:MyMatch2(<q-args>)
function! s:MyMatch2(...)
  if a:1 == ""
    2match none
  else
    execute "2match statuslineterm `\\v".a:1."`"
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! CleanEmptyBuffers call s:CleanEmptyBuffers()
function! s:CleanEmptyBuffers()
  let l:filter = 'buflisted(v:val)
                     \  && empty(bufname(v:val))
                     \  && bufwinnr(v:val)<0
                     \  && !getbufvar(v:val, "&mod")'
  let l:buffers = filter(range(1, bufnr('$')), l:filter)
  if !empty(l:buffers)
    exe 'bd ' . join(l:buffers, ' ')
  endif
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -complete=file_in_path -nargs=1 Find call s:Find(<q-args>)
function! s:Find(...)
  if a:0 < 1
    return
  endif
  let temp = &grepformat
  set grepformat=%f
  let exeString = "silent grep --files --iglob ".a:1
  execute(exeString)
  execute('set grepformat='.temp)
endfunction
"""""""""""""""""""""""""""""""""""""""""""""""""""""
command! -nargs=0 RegisterTerminalBuffer let t:termBufNr = bufnr()

function! s:GetTermBufNr()
  let termBuf = get(t:,'termBufNr',-1)
  if termBuf < 0
    echoerr "RegisterTerminalBuffer first"
  endif
  return termBuf
endfunction

function! s:SendGDBLineCommand(termBuf, command)
  let l:file = expand("%:.:")
  let l:line = line(".")
  let pos = l:file..':'..l:line
  call term_sendkeys(a:termBuf, a:command.." "..pos.."\<cr>")
endfunction

function! s:SendGDBCommand(termBuf, command)
  call term_sendkeys(a:termBuf, a:command.."\<cr>")
endfunction

command! -nargs=0 Break call s:BreakGDB()
function! s:BreakGDB()
  let termBuf = s:GetTermBufNr()
  if termBuf > 0
    call s:SendGDBLineCommand(termBuf, "b")
  endif
endfunction

command! -nargs=0 Tbreak call s:TbreakGDB()
function! s:TbreakGDB()
  let termBuf = s:GetTermBufNr()
  if termBuf > 0
    call s:SendGDBLineCommand(termBuf, "tb")
  endif
endfunction

command! -nargs=0 Until call s:UntilGDB()
function! s:UntilGDB()
  let termBuf = s:GetTermBufNr()
  if termBuf > 0
    call s:SendGDBCommand(termBuf, "u")
  endif
endfunction

command! -nargs=0 Continue call s:Continue()
function! s:Continue()
  let termBuf = s:GetTermBufNr()
  if termBuf > 0
    call s:SendGDBCommand(termBuf, "continue")
  endif
endfunction

command! -nargs=0 Pause call s:Pause()
function! s:Pause()
  let termBuf = s:GetTermBufNr()
  if termBuf > 0
    call s:SendGDBCommand(termBuf, "\<c-c>")
  endif
endfunction

command! -nargs=* -complete=tag Evaluate call s:Evaluate(<q-args>)
function! s:Evaluate(...)
  let termBuf = s:GetTermBufNr()
  let eval_expression = a:1
  if (len(eval_expression) == 0)
    let eval_expression = expand('<cexpr>')
  endif
  if termBuf > 0
    call s:SendGDBCommand(termBuf, 'p '..eval_expression)
  endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Custom Netrw Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""
function! SetLocalDir(islocal)
    return "lcd %:p:h|pwd"
endfunction
let g:Netrw_UserMaps=[["l","SetLocalDir"]]
"""""""""""""""""""""""""""""""""""""""""""""""""""""
"Auto Functions
"""""""""""""""""""""""""""""""""""""""""""""""""""""
let ftToNotSetHidden = ['netrw']
augroup vimrc
  autocmd! vimrc
  au VimEnter * call s:SetupPlugins()
  au BufNewFile,BufRead,BufEnter *.s43,*.S43 set ft=msp | set shiftwidth=2 | set tabstop=2 |set softtabstop=2
  au BufNewFile,BufRead *.au3 set ft=autoit
  au BufNewFile,BufRead *.gdb set ft=gdb
  au BufNewFile,BufRead Makefile* set ft=make
  au BufNewFile,BufRead *.make set ft=make
  au BufNewFile,BufRead *.mk set ft=make
  au BufNewFile,BufRead *.md setlocal textwidth=80
  au BufNewFile,BufRead,BufEnter *.zig set shiftwidth=4 | set tabstop=4 |set softtabstop=4
  au BufNewFile,BufRead,BufEnter *.c set shiftwidth=2 | set tabstop=2 |set softtabstop=2
  " Don't scan include files
  au BufEnter * set complete-=i
  au BufEnter * set complete-=u
  "turn off cursorline when diffing
  au BufEnter,BufNew * if &diff | set nocursorline | endif
  au BufNewFile,BufRead *.xaml set ft=xml
  au FileType make setlocal noexpandtab
  "netrw keeps setting nohidden!
  autocmd BufEnter * if index(ftToNotSetHidden, &ft) < 0 | set hidden
augroup END

let g:onedark_termcolors=256
set background=dark
silent! colorscheme onedark

if has('win32')
  silent! set guifont=Consolas:h8
else
  silent! set guifont=Inconsolata\ Medium\ 10,\ Monospace\ 10
endif

let g:netrw_banner = 0
